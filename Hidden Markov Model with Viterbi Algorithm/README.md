# ECE 208 Homework 4: Profile Hidden Markov Model (HMM)

In this problem set, you will work with the profile HMM. You will be given profile HMM models and will write code to implement the Viterbi and Forward algorithms. We have built a Python class ```HMM``` (see ```HMM.py```) to represent a profile HMM which contains all the required parameters (i.e. the alphabet and the emission and transition proabilities). In addition, the methods and scripts to load the model from file and input/output routines are all provided. You should first read ```HW4_supportive_info.pdf``` for detailed descriptions about the ```HMM``` class and its usage.

## Representation of a path in the HMM
We refer to a matching state as 'M', insertion state as 'I', and deletion state as 'D'. 
To represent a path in the HMM that generates a particular sequence s, we use upper case/lower case letters to indicate a visit of an M/I state that emits that letter. For a visit of a D state, we encode it with a dash '-'. The starting state B and the ending state E are implicitly added before the first and after the last letters.
* For example, the path `B->I0->M1->D2->M3->E` which emits the sequence ACT is represented as `aC-T`. The string `ACT` is called a **query sequence** and `aC-T` is an **aligned sequence** of `ACT` to the HMM model. 
* Note that not all aligned sequences are *valid*: an aligned sequence is *valid* if and only if it represents a possible path in the HMM which starts from B and ends at E.

## Problem 0: compute likelihood of an aligned sequence
In the ```HMM.py``` file, you will see the method ```compute_likelihood``` inside the HMM class. This method computes the log-likelihood of an aligned sequence to the HMM model and returns the log-likelihood value (if the aligned sequence is invalid, it will return -inf). You should read and understand this method as it will be helpful for you to implement and debug the other programming problems in this assignment. The script ```HMM_compute_llh.py``` is also provided. Type ```python HMM_compute_llh.py -h``` to learn how to use it. Toy examples are given in the ```Examples``` folder. Try ```python HMM_compute_llh.py -m Examples/test1/model.hmm -q Examples/test1/aln_path.txt``` and examine the output. You can also try the other two tests.

## Problem 1: Viterbi Algorithm
Recall that the purpose of the Viterbi algorithm is to find the most probable path in the HMM which generates a specified query. In the context of the profile HMM, this task is also termed **sequence-model alignment**, since it "aligns" a query sequence to the model and produces an aligned sequence that has the maximum likelihood (ML). Write a method for the HMM class to realize this algorithm and analyze the time complexity.

### Input: 
   + HMM model: an instance of the HMM class
   + Query sequence: a string
   
### Output:
An aligned sequence of the input query that has the ML to the HMM and its log-likelihood. Output "$" and "-inf" if the query cannot be generated by the specified model.

The method ```Viterbi``` is provided in the HMM class ```HMM.py``` with some guidance code. You will complete the method by filling in your code in the part marked as **YOUR CODE HERE**. To further assist you with this problem, the Viterbi recursive formula is provided in ```HW4_supportive_info.pdf```.

## Problem 2: Forward Algorithm
Recall that the purpose of the Forward algorithm is to compute the marginal probability of a query sequence given an HMM model.
### 2.1 Recursive formula
Write the recursive formula for the Forward algorithm. You must use the same set of notations as in the Viterbi formula given to you.
### 2.2 Implementation 
Write a method for the HMM class to realize this algorithm and analyze the time complexity.

### Input: 
   + HMM model: an instance of the HMM class
   + Query sequence: a string
   
### Output:
The log of the marginal probability of the query sequence given the HMM model.

For a given query, we refer to the log-likelihood of the most probable path (found by the Viterbi algorithm) as its **Vscore**, and the log of the marginal probability (computed by the Forward algorithm) as its **Fscore**. To help you test your code for part 1 and part 2, we provide the script ```HMM_query.py``` which loads a HMM model and a set of queries in ```fasta``` format, runs the ```Viterbi``` and ```Forward``` methods you implemented, and outputs the results to a specified file. The columns in the output file are query name, Vscore, Fscore, and aligned sequence, respectively. The usage of ```HMM_query.py``` is straightforward, type ```python HMM_query.py -h``` to learn. Toy examples are provided in ```Examples``` folder. Try ```python HMM_query.py -m Examples/test1/model.hmm -q Examples/test1/queries.fas -o <YOUR_OUTPUT_FILE>``` and compare your output with ```Examples/test1/scores.txt```. The same for ```test2``` and ```test3```.

## Problem 3: Classification of the Covid-19 sequences using profile HMM 
You will use profile HMM to classify amino acid sequences of the Covid-19 samples into protein families. In the ```Data``` folder, you will find 11 HMM models named ```PF*.hmm``` and 10 query sequences in the file ```queries.fas``` . Run ```HMM_query.py``` to compute the Vscore and Fscore of the queries to each of the HMM models and assign each query to the model that has the highest score. Should you use Vscore or Fscore for the classification? Clearly state your choice in the report and your reasonings for it. Produce the file ```Data/query_class.txt``` with 10 rows for the 10 queries and 4 columns: query name, assigned model, score, and aligned sequence.

## Deliverables:
* [HMM.py](HMM.py): implementation of problem 1 and problem 2
* [writeup.pdf](writeup.pdf): 
   * Analyses of the time complexity in problem 1 and problem 2
   * Recursive formula of the Forward algorithm in problem 2
   * Discussions about the score you use for the classification task in problem 3

## Grade Breakdown (100 Points)
* **Problem 1: 40 Points**
   * Correctly compute **Vscore**: 25 Points
   * Time complexity analysis: 5 Points
   * Correctly find a ML aligned sequence: 10 Points
* **Problem 2: 40 Points**
   * Recursive formula for the Forward algorithm: 10 Points
   * Time complexity analysis: 5 Points
   * Correctly compute **Fscore**: 25 Points
* **Problem 3: 20 Points**
   * Classification Accuracy: 10 Points
   * Correctness of the score and the aligned sequence: 10 Points
   
## Final Remarks:
* You have the freedom to modify the body of the two methods ```Viterbi``` and ```Forward``` inside the file ```HMM.py```. However, you **must not** change the method's name and **must not** modify anything else in the provided package. This is important for us to grade your work.
* While you implement the Forward algorithm, you may (or may not) encounter underflow problem which arises when multiplying many extremely small numbers. In such a case, you may find the function ```log_sum_exp``` in the file ```HMM.py``` helpful.
